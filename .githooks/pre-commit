#!/usr/bin/env bash
set -euo pipefail

log() {
  printf '%s\n' "[pre-commit] $*" >&2
}

die() {
  log "ERROR: $*"
  exit 1
}

print_paths() {
  local label="$1"
  shift
  log "${label}:"
  local p
  for p in "$@"; do
    log "  - ${p}"
  done
}

print_allowlist() {
  log "Allowed top-level components:"
  log "  - .agents"
  log "  - .githooks"
  log "  - .github"
  log "  - agents_runner"
  log "  - agents_runner.egg-info"
  log "  - .gitignore"
  log "  - AGENTS.md"
  log "  - README.md"
  log "  - main.py"
  log "  - pyproject.toml"
}

print_remediation_root() {
  log "Remediation:"
  log "  - Unstage disallowed paths: git restore --staged -- <path>..."
  log "  - Move/rename under an allowed top-level component, then: git add -- <new-paths>"
  log "  - Or stop tracking paths: git rm -r --cached -- <path>..."
  log "  - Common destinations: agents_runner/ (code), .agents/implementation/ (notes), .agents/tasks/wip/ (work), .agents/temp/ (temporary artifacts)"
}

is_agents_md_path_ci() {
  local path_lower="${1,,}"
  case "${path_lower}" in
    "agents.md"|\
    ".agents/tasks/agents.md"|\
    ".agents/tasks/wip/agents.md"|\
    ".agents/tasks/done/agents.md"|\
    ".agents/tasks/taskmaster/agents.md"|\
    ".agents/tasks/not-ready/agents.md")
      return 0
      ;;
  esac
  return 1
}

repo_root="$(git rev-parse --show-toplevel)"
cd "${repo_root}"

mapfile -d '' -t staged_paths < <(git diff --cached --name-only -z --diff-filter=ACMR)

declare -A root_allowlist=(
  [".agents"]=1
  [".githooks"]=1
  [".github"]=1
  ["agents_runner"]=1
  ["agents_runner.egg-info"]=1
  [".gitignore"]=1
  ["AGENTS.md"]=1
  ["README.md"]=1
  ["main.py"]=1
  ["pyproject.toml"]=1
)

disallowed_staged_paths=()
for path in "${staged_paths[@]}"; do
  [[ -z "${path}" ]] && continue
  top_level="${path%%/*}"
  if [[ "${top_level,,}" == "agents.md" ]]; then
    continue
  fi
  if [[ -z "${root_allowlist["$top_level"]+x}" ]]; then
    disallowed_staged_paths+=("${path}")
  fi
done

if ((${#disallowed_staged_paths[@]} > 0)); then
  log "ERROR: Disallowed staged paths detected (root allowlist enforcement)."
  print_paths "Disallowed staged paths" "${disallowed_staged_paths[@]}"
  print_allowlist
  print_remediation_root
  exit 1
fi

had_structure_error=0

audit_tracked=()
mapfile -d '' -t audit_tracked < <(git ls-files -z -- .agents/audit)
audit_required=".agents/audit/AGENTS.md"

staged_name_status=()
mapfile -d '' -t staged_name_status < <(git diff --cached --name-status -z --diff-filter=DR)
protected_agents_deletions=()
status_idx=0
while ((status_idx < ${#staged_name_status[@]})); do
  status="${staged_name_status[$status_idx]}"
  status_idx=$((status_idx + 1))
  case "${status}" in
    D*)
      old_path="${staged_name_status[$status_idx]:-}"
      status_idx=$((status_idx + 1))
      if is_agents_md_path_ci "${old_path}"; then
        protected_agents_deletions+=("${old_path}")
      fi
      ;;
    R*)
      old_path="${staged_name_status[$status_idx]:-}"
      new_path="${staged_name_status[$((status_idx + 1))]:-}"
      ((status_idx+=2))
      if is_agents_md_path_ci "${old_path}" && ! is_agents_md_path_ci "${new_path}"; then
        protected_agents_deletions+=("${old_path} -> ${new_path}")
      fi
      ;;
    *)
      status_idx=$((status_idx + 1))
      ;;
  esac
done

if ((${#protected_agents_deletions[@]} > 0)); then
  log "ERROR: Protected AGENTS.md paths must never be deleted from task folders or repo root."
  print_paths "Blocked AGENTS deletions/renames" "${protected_agents_deletions[@]}"
  log "How to fix:"
  log "  - Restore AGENTS.md files in protected locations and stage them."
  log "  - Allowed protected locations (case-insensitive basename match):"
  log "      AGENTS.md"
  log "      .agents/tasks/AGENTS.md"
  log "      .agents/tasks/wip/AGENTS.md"
  log "      .agents/tasks/done/AGENTS.md"
  log "      .agents/tasks/taskmaster/AGENTS.md"
  log "      .agents/tasks/not-ready/AGENTS.md"
  had_structure_error=1
fi

audit_missing=0
audit_extra=()
audit_has_required=0
for path in "${audit_tracked[@]}"; do
  if [[ "${path}" == "${audit_required}" ]]; then
    audit_has_required=1
    continue
  fi
  audit_extra+=("${path}")
done
if [[ "${audit_has_required}" -eq 0 ]]; then
  audit_missing=1
fi
if [[ "${audit_missing}" -eq 1 || ${#audit_extra[@]} -gt 0 ]]; then
  log "ERROR: .agents/audit must contain exactly ${audit_required} in the index."
  if [[ "${audit_missing}" -eq 1 ]]; then
    log "Missing required path:"
    log "  - ${audit_required}"
  fi
  if ((${#audit_extra[@]} > 0)); then
    print_paths "Disallowed tracked paths under .agents/audit" "${audit_extra[@]}"
  fi
  log "How to fix:"
  log "  - Remove/move extra files out of .agents/audit, then: git rm -r --cached -- .agents/audit/<path>"
  log "  - Ensure required file exists and is tracked: mkdir -p .agents/audit && touch .agents/audit/AGENTS.md && git add .agents/audit/AGENTS.md"
  had_structure_error=1
fi

tasks_tracked=()
mapfile -d '' -t tasks_tracked < <(git ls-files -z -- .agents/tasks)

tasks_required=(
  ".agents/tasks/AGENTS.md"
  ".agents/tasks/wip/AGENTS.md"
  ".agents/tasks/done/AGENTS.md"
  ".agents/tasks/taskmaster/AGENTS.md"
  ".agents/tasks/not-ready/AGENTS.md"
)

declare -A tasks_required_set=()
declare -A tasks_required_lower_set=()
for path in "${tasks_required[@]}"; do
  tasks_required_set["$path"]=1
  tasks_required_lower_set["${path,,}"]=1
done

tasks_missing=()
for required_path in "${tasks_required[@]}"; do
  required_lower="${required_path,,}"
  required_found=0
  for tracked_path in "${tasks_tracked[@]}"; do
    if [[ "${tracked_path,,}" == "${required_lower}" ]]; then
      required_found=1
      break
    fi
  done
  if [[ "${required_found}" -eq 0 ]]; then
    path="${required_path}"
    tasks_missing+=("$path")
  fi
done

tasks_invalid=()
tasks_has_task_files=0
for path in "${tasks_tracked[@]}"; do
  if [[ -n "${tasks_required_set["$path"]+x}" || -n "${tasks_required_lower_set["${path,,}"]+x}" ]]; then
    continue
  fi
  if [[ "${path}" =~ ^\.agents/tasks/not-ready/[^/]+\.(md|txt)$ ]]; then
    continue
  fi
  if [[ "${path}" =~ ^\.agents/tasks/(wip|done|taskmaster)/[^/]+\.(md|txt)$ ]]; then
    tasks_has_task_files=1
    continue
  fi
  tasks_invalid+=("${path}")
done

if ((${#tasks_missing[@]} > 0 || ${#tasks_invalid[@]} > 0)); then
  log "ERROR: .agents/tasks structure is invalid in the index."
  if ((${#tasks_missing[@]} > 0)); then
    print_paths "Missing required paths" "${tasks_missing[@]}"
  fi
  if ((${#tasks_invalid[@]} > 0)); then
    print_paths "Invalid tracked paths under .agents/tasks" "${tasks_invalid[@]}"
  fi
  log "How to fix:"
  log "  - Ensure required AGENTS.md files exist:"
  log "      mkdir -p .agents/tasks/{wip,done,taskmaster,not-ready} \\"
  log "        && touch .agents/tasks/AGENTS.md .agents/tasks/wip/AGENTS.md .agents/tasks/done/AGENTS.md .agents/tasks/taskmaster/AGENTS.md .agents/tasks/not-ready/AGENTS.md \\"
  log "        && git add -- .agents/tasks/AGENTS.md .agents/tasks/wip/AGENTS.md .agents/tasks/done/AGENTS.md .agents/tasks/taskmaster/AGENTS.md .agents/tasks/not-ready/AGENTS.md"
  log "  - Remove/move invalid paths (no files directly under .agents/tasks except AGENTS.md; no deeper nesting; only .md/.txt task files at depth 2):"
  log "      git rm -r --cached -- <invalid-paths>...   # or move then git add"
  had_structure_error=1
fi

if [[ "${had_structure_error}" -eq 1 ]]; then
  exit 1
fi

if [[ "${tasks_has_task_files}" -eq 1 ]]; then
  log "WARNING: Task files (.md/.txt) exist under .agents/tasks/{wip,done,taskmaster}."
fi

if ! command -v uv >/dev/null 2>&1; then
  die "uv not found; install uv to run compile checks (or use --no-verify to bypass)"
fi

uv_project_env="${UV_PROJECT_ENVIRONMENT:-/tmp/agents-runner-precommit-uv-env}"
if ! UV_PROJECT_ENVIRONMENT="${uv_project_env}" uv run python -m compileall -q agents_runner main.py; then
  die "Compile check failed. Fix by running the command above and addressing the reported issues."
fi

if ! UV_PROJECT_ENVIRONMENT="${uv_project_env}" uv run python - <<'PY'
import importlib

modules = [
    "agents_runner",
    "agents_runner.ui.runtime.app",
    "agents_runner.ui.main_window",
]

for module in modules:
    importlib.import_module(module)
print("ok")
PY
then
  log "WARNING: import smoke test failed; fix by running the command above and addressing the import error."
fi

log "OK"
